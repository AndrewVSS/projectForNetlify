{"mappings":"AAAA,kBAAkB;AAClB,MAAM,SAAS;AACf,iEAAiE;AACjE,IAAI,SAAS,CAAC;AACd,IAAI,YAAY,CAAC;AACjB,2DAA2D;AAC3D,IAAI,WAAW,CAAC,MAAM,mBAAqB;IACvC,OAAO,SAAS,CAAC,KAAK,GAAG;AAC7B;AAEA,UAAU,KAAK,GAAG;AAClB,sFAAsF;AACtF,sFAAsF;AACtF,wCAAwC;AACxC,IAAI,QAAQ,CAAC,MAAM,WAAa;IAC5B,IAAI,OAAO,YAAY,YACnB,OAAO,MAAM,CAAC,KAAK,GAAG;SACnB,IAAI,OAAO,YAAY,UAC1B,OAAO,MAAM,CAAC,KAAK,GAAG,SAAS,CAAC,SAAS;SAEzC;AAER;AACA,0BAA0B;AAC1B,SAAS,aAAa,IAAM;IACxB,IAAI,QAAQ,SAAS,cAAc,CAAC;IACpC,MAAM,SAAS,GAAG;IAClB,MAAM,QAAQ,WAAW,SAAS,eAAe;IACjD,MAAM,QAAQ,WAAW,SAAS,eAAe;IACjD,MAAM,WAAW,CAAC;IAClB,OAAO,MAAM,WAAW,CAAC;AAC7B;AAEA,uCAAuC;AACvC,MAAM,KAAK;AAEX,kCAAkC;AAClC,IAAI,YAAY,CAAC,IAAI,YAAc;IAC/B,IAAI,IAAI,SAAS,aAAa,CAAC;IAC/B,EAAE,EAAE,GAAG;IACP,EAAE,SAAS,GAAG;IACd,OAAO,EAAE,UAAU;AACvB;AACA,oCAAoC;AACpC,IAAI,aAAa,CAAC,OAAO,MAAM,OAAS;IACpC,IAAI,IAAI,SAAS,aAAa,CAAC;IAC/B,IAAI,WAAW,SAAS,cAAc,CAAC;IACvC,EAAE,WAAW,CAAC;IACd,EAAE,KAAK,GAAG;IACV,EAAE,IAAI,GAAG;IACT,OAAO;AACX;AAEA,kDAAkD;AAClD,IAAI,eAAe,CAAC,QAAU;IAC1B,IAAI;QACA,OAAO,MAAM,CAAC,MAAM;IACxB,EAAE,OAAO,OAAO;QACZ,MAAM,IAAI,MAAM,4BAA4B;IAChD;AACJ;AACA,iFAAiF;AACjF,IAAI,SAAS,CAAC,MAAQ;IAClB,MAAM,MAAM,OAAO,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM;IAC7C,MAAM,gBAAgB,aAAa;IACnC;AACJ;AACA,gEAAgE;AAChE,OAAO,gBAAgB,CAAC,QAAQ;AAChC,OAAO,gBAAgB,CAAC,cAAc","sources":["src/index.js"],"sourcesContent":["// Application div\nconst appDiv = \"app\";\n// Both set of different routes and template generation functions\nlet routes = {};\nlet templates = {};\n// Register a template (this is to mimic a template engine)\nlet template = (name, templateFunction) => {\n    return templates[name] = templateFunction;\n};\n\ntemplates.chats = template\n// Define the routes. Each route is described with a route path & a template to render\n// when entering that path. A template can be a string (file name), or a function that\n// will directly create the DOM objects.\nlet route = (path, template) => {\n    if (typeof template == \"function\") {\n        return routes[path] = template;\n    } else if (typeof template == \"string\") {\n        return routes[path] = templates[template];\n    } else {\n        return;\n    }\n};\n// Register the templates.\ntemplate('template1', () => {\n    let myDiv = document.getElementById(appDiv);\n    myDiv.innerHTML = \"\";\n    const link1 = createLink('view1', 'Go to view1', '#/view1');\n    const link2 = createLink('view2', 'Go to view2', '#/view2');\n    myDiv.appendChild(link1);\n    return myDiv.appendChild(link2);\n});\n\n// Define the mappings route->template.\nroute('/', 'template1');\n\n// Generate DOM tree from a string\nlet createDiv = (id, xmlString) => {\n    let d = document.createElement('div');\n    d.id = id;\n    d.innerHTML = xmlString;\n    return d.firstChild;\n};\n// Helper function to create a link.\nlet createLink = (title, text, href) => {\n    let a = document.createElement('a');\n    let linkText = document.createTextNode(text);\n    a.appendChild(linkText);\n    a.title = title;\n    a.href = href;\n    return a;\n};\n\n// Give the correspondent route (template) or fail\nlet resolveRoute = (route) => {\n    try {\n        return routes[route];\n    } catch (error) {\n        throw new Error(\"The route is not defined\");\n    }\n};\n// The actual router, get the current URL and generate the corresponding template\nlet router = (evt) => {\n    const url = window.location.hash.slice(1) || \"/\";\n    const routeResolved = resolveRoute(url);\n    routeResolved();\n};\n// For first load or when routes are changed in browser url box.\nwindow.addEventListener('load', router);\nwindow.addEventListener('hashchange', router);"],"names":[],"version":3,"file":"index.579125c3.js.map","sourceRoot":"/__parcel_source_root/"}